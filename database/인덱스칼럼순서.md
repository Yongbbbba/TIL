```mssql
USE Northwind;





-- 복합 인덱스 컬럼 순서

-- INDEX(A,B,C)



-- 북마크 룩업

-- Leaf Page 탐색은 여전히 존재하기 때문

-- [레벨, 종족] 인덱스. (56 휴먼)



SELECT * 

INTO TestOrders 

FROM Orders;



DECLARE @i INT = 1;

DECLARE @emp INT; 

SELECT @emp = MAX(EmployeeID) FROM Orders;



-- 더미 데이터를 엄청 늘린다 

SELECT *

FROM TestOrders;



SELECT *

FROM Orders;



WHILE (@i < 1000)

BEGIN 

 INSERT INTO Testorders(CustomerID, EmployeeID, OrderDate)

 SELECT CustomerID, @emp + @i, OrderDate

 FROM Orders;

 SET @i = @i + 1;

END



SELECT COUNT(*)

FROM Testorders;



CREATE NONCLUSTERED INDEX idx_emp_ord

ON TestOrders(EmployeeID, OrderDate);



CREATE NONCLUSTERED INDEX idx_ord_emp

ON TestOrders(OrderDate, EmployeeID);



SET STATISTICS TIME ON;

SET STATISTICS IO ON;



SELECT *

FROM TestOrders WITH(INDEX(idx_emp_ord))  -- 사용할 인덱스 지정해줘서 확인

WHERE EmployeeID = 1 AND OrderDate = CONVERT(DATETIME, '19970101');



SELECT *

FROM TestOrders WITH(INDEX(idx_ord_emp))  -- 사용할 인덱스 지정해줘서 확인

WHERE EmployeeID = 1 AND OrderDate = CONVERT(DATETIME, '19970101');



-- 직접 살펴보자

SELECT * 

FROM Testorders

ORDER BY EmployeeID, OrderDate;



SELECT * 

FROM Testorders

ORDER BY OrderDate, EmployeeID;



-- 범위로 찾는다면?



SELECT *

FROM TestOrders WITH(INDEX(idx_emp_ord))  -- 사용할 인덱스 지정해줘서 확인

WHERE EmployeeID = 1 AND OrderDate BETWEEN '19970101' AND '19970103';



SELECT *

FROM TestOrders WITH(INDEX(idx_ord_emp))  -- 사용할 인덱스 지정해줘서 확인

WHERE EmployeeID = 1 AND OrderDate BETWEEN '19970101' AND '19970103';





 -- [!] Index(a,b,c)로 구성되었을 때, 선행에 between 사용 = 후행은 인덱스 기능 x

 -- 다시 말해서 between을 사용할 경우 인덱스 지정 순서를 후행에 해야함.

 -- 그럼 between 같은 비교가 등장하면 인덱스 순서만 무조건 바꿔주면 될까? -> NO



 -- BETWEEN 범위가 작을 때 -> IN-LIST로 대체하는 것을 고려(사실상 여러번 비교연산 사용한 것)

 SET STATISTICS PROFILE ON;



SELECT *

FROM TestOrders WITH(INDEX(idx_ord_emp))  -- 사용할 인덱스 지정해줘서 확인

WHERE EmployeeID = 1 AND OrderDate IN('19970101', '19970102', '19970103');

-- 논리적 읽기가 줄어든다.

-- PROFILE로 까보면 하나하나 분리해서  OR문으로 세 번 나눠서 검색.



-- 오늘의 결론 -- 

-- 복합 컬럼 인덱스 (선행, 후행) 순서가 영향을 줄 수 있음

-- BETWEEN, 부등호(> <) 선행에 들어가면, 후행은 인덱스 기능을 상실 

-- BETWEEN 범위가 적으면 IN-LIST로 대체하면 좋은 경우도 있다. (선행에 BETWEEN이 들어간 경우)

-- 선행=, 후행BETWEEN이라면, 아무런 문제가 없기 때문 IN-LIST X


```

