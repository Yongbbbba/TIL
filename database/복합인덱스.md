```mssql
-- 복합 인덱스

-- 여러 컬럼에 동시에 인덱스를 거는 것



-- 주문 상세 정보를 살펴보자

SELECT *

FROM [Order Details]

ORDER BY OrderID;  -- OrderID가 같은 행이 여러개 있는 경우에 인덱스를 걸면 무슨 일이 일어나나? 



-- 임시 테스트 테이블을 만들고 데이터 복사한다

SELECT *

INTO TestOrderDetails

FROM [Order Details];



-- 복합 인덱스 추가 

CREATE INDEX Index_TestOrderDetails

ON TestOrderDetails(OrderID, ProductID);



-- 인덱스 정보 살펴보기

EXEC sp_helpindex 'TestOrderDetails';



-- (OrderID, ProductID)둘다 한 번에 서칭하는 경우, 각각을 서칭하는 경우 속도차이?

-- index scan(index full scan의 약자, 굉장히 나쁜 상황) -> BAD

-- index seek -> GOOD, 인덱스가 정상적으로 활용이 된다고 보면 되는 경우



-- 인덱스 정보 테스트1 -> GOOD

SELECT *

FROM TestOrderDetails

WHERE OrderID=10248 AND ProductID=11;



-- 인덱스 정보 테스트2 -> GOOD

SELECT *

FROM TestOrderDetails

WHERE ProductID=11 AND OrderID=10248 ;



-- 인덱스 정보 테스트3 -> GOOD

SELECT *

FROM TestOrderDetails

WHERE OrderID=10248 ;



-- 인덱스 정보 테스트3 -> BAD(index scan)

SELECT *

FROM TestOrderDetails

WHERE ProductID=11 ;



-- 왜 이런 일이 일어나나?

-- 인덱스를 생성할 때 먼저 orderID로 정렬을 하고 그 다음에 productID로 정렬을 했기 때문이다.



DBCC IND('Northwind', 'TestOrderDetails', 2);

DBCC PAGE('Northwind', 1, 860, 3);



-- 따라서 인덱스(A,B) 사용중이라면 인덱스(A) 없어도 무방

-- 하지만 B로도 검색이 필요하다고 하면 인덱스(B)는 별도로 걸어줘야 함



-- 인덱스는 데이터가 추가/갱신/삭제 유지되어야 함

-- 페이지 용량을 이미 꽉 채우고 있는데 삽입이 된다면? 



-- 데이터 50개를 강제로 넣어보자. 

-- 결론: 페이지 여유 공간이 없다면 -> 페이지 분할(SPLIT)이 발생



-- 가공 테스트

SELECT LastName

INTO TestEmployees

FROM Employees;



SELECT * FROM TestEmployees;



-- 인덱스 추가

CREATE INDEX Index_TestEmployees

ON TestEmployees(LastName);



-- INDEX SCAN -> BAD

SELECT * 

FROM TestEmployees

WHERE SUBSTRING(LastName, 1,2) = 'Bu';

-- 인덱스를 가공해서 쓰면 인덱스가 올바르게 활용되지 않을 수도 있음에 유의



-- INDEX SEEK

SELECT * 

FROM TestEmployees

WHERE LastName LIKE 'Bu%';



-- 실행 계획을 살펴보는 것이 매우 중요하다! 



-- 오늘의 결론

-- 복합 인덱스(A, B)를 사용할 때 순서 주의(A->B 순서 검색)

-- 인덱스를 사용 시, 데이터 추가로 인해 페이지 여유 공간이 없으면 SPLIT

-- 키 가공할 때 주의!

```

