```mysql
-- 북마크 룩업 



-- Index Scan vs Index Seek

-- Index Scan이 항상 나쁜 것은 아니고 

-- Index Seek이 항상 좋은 것은 아니다.

-- 인덱스를 활용하는데 어떻게 느릴 수 있을까? 

-- 그 원인은 북마크 룩업에 있다.



-- Nonclustered





-- Clustered



-- Clustered의 경우 index seek가 느릴 수가 없다 

-- Nonclustered의 경우, 데이터가 leaf page에 없다. 

-- 따라서 한 번 더 타고 가야함

-- 1) RID -> heap table (bookmark lookup)

-- 2) key -> clustered

-- 이렇게 bookmark lookup을 하기 때문에 오히려 index scan보다 느린 경우가 생길수도 있다.



SELECT *

INTO Testorders

FROM Orders;



select *

from Testorders;



create nonclustered index Orders_Index01

on Testorders(CustomerID);



-- 조회 

dbcc ind('Northwind','TestOrders', 2);

-- 클러스터 인덱스를 안만들었으니까 Heap Table이 존재할 것.

set statistics profile on;



-- 기본 탐색을 해보자

select *

from Testorders

where CustomerID = 'QUICK';



select *

from Testorders with(index(Orders_Index01))

where CustomerID = 'QUICK';

-- 항상 인덱스 쓰는게 최선이 아니고 풀 스캔이 빠른 경우도 존재한다.

-- 룩업 테이블을 확인할 때, 필요한 데이터, 룩업 테이블이 메모리에 올라와있다는 보장이 없기 때문에 하드에서 확인을 해서 추출하면 시간이 오래 걸린다.





-- 룩업을 줄이기 위한 몸부림

-- Covered Index

select *

from Testorders with(index(Orders_Index01))

where CustomerID = 'QUICK' and ShipVia=3;



drop index TestOrders.Orders_Index01;



create nonclustered index Orders_Index01

on Testorders(CustomerID, ShipVia);



-- 8번 룩업을 시도해서 8번 다 꽝없이 찾음

select *

from Testorders with(index(Orders_Index01))

where CustomerID = 'QUICK' and ShipVia=3;



-- Q) 그럼 조건1 and 조건2 필요하면, 무조건 인덱스를 걸 때 복합인덱스(조건1,조건2)를 추가해주면 장땡?

-- A) no! 꼭 그렇지는 않다. DML(Insert, update, delete)할 때 작업 부하가 커진다. 검색은 빨라져도.

-- 정렬 상태의 변화가 생기기 때문에. 페이지에 변화가 생기고.



-- 룩업을 줄이기 위한 몸부림 

create nonclustered index Orders_Index01

on Testorders(CustomerID) include (ShipVia);

-- key는 하나가 설정되어도, 리프 페이지에 shipvia에 대한 정보를 추가로 들고 있겠다는 것.



-- 결론

-- 논클러스터 인덱스가 악영향을 주는 경우? 

-- 북마크 룩업이 심각한 부하를 야기할 때

-- 대안? 

-- 옵션1) covered index(검색할 모든 칼럼을 포함하겠다)

-- 옵션2) index에다가 include로 힌트를 남긴다.

-- 옵션3) 클러스터 인덱스를 고려한다.(단, 1번만 사용할 수 있는 궁극기) ->? 논클러스터에 악영향을 줄 수도 있으니 주의.


```

