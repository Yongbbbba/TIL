늘 헷갈리는 동기 비동기 / block non-block

![image-20210729163616888](동기비동기블락논블락.assets/image-20210729163616888.png)

# block vs non-block

- block: 어떤 함수를 호출했을 때 return될 때까지 block되어있는 상태를 말한다. 예를 들어 어떤 파일을 읽는 작업을 수행할 때 요청한 파일을 return 받을 때까지 그 다음 명령으로 넘어가지 않는 상태를 말한다.
- non-block: 어떤 함수를 호출했을 때 무조건 바로 return을 해버리는 것을 말한다. 어떤 파일을 읽는 작업을 수행했을 때 파일을 받았건 안받았건 일단 return을 한 다음에 여러 방법을 통해서 원하는 파일을 받았는지 추후에 확인할 필요가 생긴다.



# 동기 vs 비동기

- 동기: 용어 그대로 동시에 일어난다라는 뜻이다. 무엇이 동시에 일어나냐면 함수의 호출과 반환이 같은 시점에 이루어진다는 것이다. 
- 비동기: 동시에 일어나지 않는다는 뜻이다. 함수를 호출했을 때 호출한 시점에 반환을 받는 것이 아니고 함수의 호출 행위 자체를 예약만 해두고 나중에 반환을 받을 수 있는 것이다. 즉 함수를 부르는 시점과 실행되는 시점이 다르다는 뜻이다. 

![image-20210729164344823](동기비동기블락논블락.assets/image-20210729164344823.png)



## 명월님의 동기 비동기 설명

안녕하세요. 명월입니다.



이 글은 C#에서 비동기 소켓 통신(IOCP) - EAP 패턴에 대한 글입니다.



약 8년전에 이 글에 대해 작성한 적이 있었는데, 그 때는 IOCP의 대한 정확한 개념없이 단순히 리소스를 아낄 수 있는 방법에 대해 작성했습니다.

먼저 IOCP에 대해 간략하게 이야기하겠습니다.



이 전에 동기 소켓 서버에 대해 글을 쓴 적이 있습니다.(이 글도 오래전에 작성한 거라 언젠간 다시 작성해야 겠네요..)

링크 - [[C# 강좌 - 32\] 소켓 통신 - 1](https://nowonbun.tistory.com/155)



여기서 동기, 비동기에 대한 의미입니다만, 저도 이 용어때문에 참 헤갈렸던 걸로 기억합니다.

먼저 동기, 비동기는 우리가 흔히 이야기하는 클라이언트와 서버간에 동기면 계속 연결이 되어있는 상태이고 비동기면 한번에 전송 후에 접속을 끊는 형태를 이야기합니다.

근데, 여기서 이야기하는 동기, 비동기 개념은 비슷한데 약간 틀립니다.

동기 소켓이나 비동기 소켓이던 클라이언트에서 접속을 하면 연결을 끊는 것이 아니고 시스템 내부에서 하나의 쓰레드로 리소스를 유지하느냐 안하느냐의 차이입니다.



즉, 동기 소켓이면 Socket 클래스로 서버를 Listen한 다음 Client가 접속을 하면 또 하나의 Socket와 Thread를 생성하여 객체를 유지하는 것입니다. 여기서 보통 Vector나 List로 Client가 접속할 때마다 Socket과 Thread를 보관하게 됩니다.

이 동기 소켓의 문제가 무엇이냐면 다중 접속일 때 문제가 발생합니다. 우리 시스템은 자원이 한정적이기 때문에 무한히 Thread와 Socket객체를 만들어 낼 수 없습니다.

게임 서버라고 가정한다면 동시 접속 200~300만 되어도 서버 프로그램에 쓰레드는 200~300개나 늘어나게 되는 것입니다. 최근에 하드웨어가 어떻게 어떻게 버틸 수는 있겠지만 C#의 장점이자 단점인 GC(가비지 컬렉션)가 우리를 기다리고 있습니다.

C#이라는 언어는 클래스를 생성을 할 수는 있지만 유저가 메모리 해제를 하지 못합니다. GC이 움직이게 됩니다. 그럴 때, 리소스를 마구잡이로 사용하고 어느 순간 GC가 움직이게 되면 서버는 프리징 상태에 빠져도 이상하지 않을 것입니다.



이걸 해결하기 위해서 있는 것이 비동기 소켓입니다. 비동기 소켓은 Client가 접속을 하면 접속할 때의 처리를 위한 이벤트가 발생하고 연결 리소스를 큐 구조의 IOCP에 쌓습니다.

그럼 Client로 부터 메시지가 올 때는 이 IOCP에서 연결 리소스를 꺼내서 프로그램으로 알려주는 것입니다. 결국은 비동기 서버는 접속시마다 Thread를 쌓을 필요가 없기 때문에 리소스를 많이 아낄 수가 있습니다.

그리고 Thread를 관리하는 ThreadPool를 만들 필요도 없고 역시, Thread를 관리할 필요도 없기 때문에 소스도 매우 간단해 집니다.



이게 동기 서버와 비동기 서버의 차이입니다.

그렇다면 비동기 서버가 메모리 효율도 좋고 소스도 훨씬 간단하면 동기 서버는 필요가 없을 듯합니다만, 꼭 그렇지는 않습니다.

비동기도 단점이 분명히 있는데, 사양의 차이입니다.

만약 Client의 액션으로 Server가 반응하는 형태, webserver나 게임 서버같은 경우는 비동기가 유리합니다.

하지만 반대로 Client의 액션이 없이도 Server가 Client로 보내는 데이터가 많을 경우, 원 프레임 단말 형식이던가 주식 차트처럼 추이 프로그램의 데이터를 계속적으로 받아야하는 형태는 동기가 훨씬 낫습니다.

이 차이는 Server에서 Client를 얼마나 잘 찾을 수 있는 것인데, 물론 비동기에서도 접속할 때마다 List에 Socket을 보관하게 되면 가능합니다만, 이럴 때는 확실히 동기식 소켓이 여러가지 편한 점이 많습니다.



출처: https://nowonbun.tistory.com/246 [명월 일지]
