# boj 17298 오큰수

- 스택 사용
- 미리 N 크기의 ans 배열을 -1로 초기화한다.
- 뒤에서부터 탐색하면서, 스택이 비어있다면 현재 위치의 값을 넣어주고, 비어있지 않다면 s.top()과 비교해서 s.top()이 현재 위치의 값보다 크다면 그것이 오큰수이다. 그러면 ans를 갱신해주고 스택에 현재 위치의 값을 넣어준다.
- 만약 s.top이 현재 위치의 값보다 작다면 큰 수가 나올 때까지 pop해준다. 



```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>

using namespace std;
vector<int> v;
stack<int> s;

int main()
{
	int N;
	cin >> N;
	for (int i = 0; i < N; i++)
	{
		int temp;
		cin >> temp;
		v.push_back(temp);
	}

	vector<int> ans(N, -1);
	int idx = N - 1;
	while (idx != -1)
	{
		if (s.empty())
		{
			s.push(v[idx]);
		}
		else
		{
			while (true)
			{
				if (s.empty())
				{
					s.push(v[idx]);
					break;
				}

				if (s.top() > v[idx])
				{
					ans[idx] = s.top();
					s.push(v[idx]);
					break;
				}
				else
				{
					s.pop();
				}
			}
		}
		idx--;
	}

	for (int i = 0; i < N; i++)
	{
		cout << ans[i] << ' ';
	}
	
	return  0;

}
```



## 1년뒤 풀이 : 2022-09-12

- stack 사용해서 풀이
- 1년 전 풀이랑 논리는 같은데 효율이 더 좋아짐
  - vector 입력받는 부분과 쓸데없이 무한반복 돌면서 if문을 계속 타게 하는게 비효율을 야기하는듯. 속도가 3배 좋아졌다.

### 코드 

```c++
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define ll long long

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	int n;
	cin >> n;
	vector<int> arr(n);
	vector<int> result(n);
	stack<int> s;


	for (int i = 0; i < n; i++) 
	{
		int num; 
		cin >> num; 
		arr[i] = num;
	}

	for (int i = n - 1; i >= 0; i--)
	{
		while (!s.empty() && s.top() <= arr[i])
		{
			s.pop();
		}

		if (s.empty())
		{
			result[i] = -1;
			s.push(arr[i]);
		}
		else 
		{
			result[i] = s.top();
			s.push(arr[i]);
		}
	}

	for (auto& num : result)
	{
		cout << num << " ";
	}

	return 0;
}
```

