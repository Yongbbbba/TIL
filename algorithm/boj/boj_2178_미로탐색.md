# BOJ_2178_미로탐색

- BFS로 거리 탐색하는 것을 이번에 처음 배웠다. 어떤 식으로 계산할 수 있을지 알게 됐다. 강의를 슬쩍 보고 풀었던 것이라서 수월하게 풀었는데, 안보고 했어도 잘 풀었으려나...?



## 코드

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int N,M;
    cin >> N >> M;
    int arr[100][100] {0};
    string a;
    // 입력받기
    for (int i=0; i<N; i++)
    {
        cin >> a;
        int j=0;
        for (auto c : a)
        {
            arr[i][j] = static_cast<int>(c-'0');
            j++;
        }
    }

    int dist[100][100]; // 거리를 입력하면서 동시에 방문지 체크할 배열
    // -1로 초기화
    for (int i=0; i<N; i++) fill(dist[i], dist[i]+M, -1);

    queue<pair<int, int>> q;

    // 출발지 집어넣기
    q.push({0,0});
    dist[0][0] = 1; // 시작위치도 칸 수에 추가

    // 네 방향
    int dr[4] = {0, 1, 0, -1};
    int dc[4] = {1, 0, -1, 0};

    int result;

    while (!q.empty())
    {
        int r = q.front().first;
        int c = q.front().second;
        q.pop();
        // 도착했는지 확인
        if (r ==  N-1 && c == M-1) 
        {
            result = dist[r][c];
            // 도착했으면 break
            break;
        }

        // 네 방향 탐색
        for (int i=0; i<4; i++)
        {
            int nr = r + dr[i];
            int nc = c + dc[i];

            if (nr < 0 || nr >= N || nc < 0 || nc >= M) continue;

            // 길이 있고, 방문하지 않은 곳이라면.
            if (arr[nr][nc] == 1 && dist[nr][nc] <= 0)
            {
                q.push({nr, nc});
                dist[nr][nc] = dist[r][c] + 1;

            }
        }
    }

    cout << result;


    return 0;

}
```



## 1년 뒤 풀이 : 2022-09-22

- 스스로 힘으로 풀지 못함

## 코드 

```c++
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define ll long long

int arr[510][510];
int vis[510][510];
int n, m;
int dx[4] = { 0, 1, 0, - 1 };
int dy[4] = { 1, 0, -1, 0 };

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); 

	cin >> n >> m;

	queue<pair<int,int>> q;
	int result;

	for (int i = 0; i < n; i++)
	{
		string temp;
		cin >> temp;
		for (int j = 0; j < m; j++)
		{
			if (temp[j] == '1')
			{
				arr[i][j] = 1;
			}
		}
	}

	q.push({ 0,0 });
	vis[0][0] = 1;
	while (!q.empty())
	{
		pair<int, int> now = q.front();
		q.pop();
		int x = now.first;
		int y = now.second;

		// 도착했는지 확인 
		if (x == n-1 && y == m-1)
		{
			result = vis[x][y];
			break;
		}

		for (int d = 0; d < 4; d++)
		{
			int nx = x + dx[d];
			int ny = y + dy[d];

			if (nx < 0 || nx >= n || ny < 0 || ny >= m)
				continue;
			if (arr[nx][ny] == 1 && vis[nx][ny] == 0)
			{
				q.push({ nx, ny });
				vis[nx][ny] = vis[x][y] + 1;
			}
		}

	}

	cout << result;
	return 0;
}
```

