# boj 16954 움직이는 미로 탈출

- 왜 시간 초과가 안나고 통과가 됐는지 이해가 안되는 문제였다. 제한 시간이 2초인데 내 코드는 예시 테스트 케이스 넣어봐도 거의 다 2초가 훨씬 넘는다. 근데 그냥 제출해봤더니 통과가 된다.
- 그냥 단순하게 BFS를 사용해서, q의 size만큼 루프를 돌면서 해당 second에서 벽과 만나거나 도착을 했는지 체크를 했다. 도착을 했다면 끝난거고, 벽과 만났으면 그건 빼고 벽과 안만났다면 9방향을 outOfBound 체크랑 벽과 만나는 지점인지 체크를 하고 q에 넣었다. 그 다음에 벽을 이동시켰다. 
- 최종적으로 도착할 수 있는지만 보면 되기 때문에 방문 체크를 할 필요가 없다. 



## 왜 통과했는지 모르겠는 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>
#include <map>

typedef long long ll;

using namespace std;
const int INF = 987654321;

vector<string> arr(8);

int dr[9] = { -1,-1,-1, 0,0,0, 1,1,1 };
int dc[9] = { -1,0,1, -1,0,1, -1,0,1 };

void moveArr()
{
    for (int i = 7; i > 0; i--)
        swap(arr[i], arr[i - 1]);
    arr[0] = "........";
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    for (int i = 0; i < 8; i++)
        cin >> arr[i];

    int result = 0; // 1은 도착
    queue<pair<int, int>> q;
    q.push({ 7,0 });
    const pair<int, int> end = make_pair(0, 7);
    
    while (!q.empty())
    {
        int qsize = q.size();
        for (int i = 0; i < qsize; i++)
        {
            int r, c;
            r = q.front().first;
            c = q.front().second;
            q.pop();

            // 도착했는지 체크
            if (make_pair(r, c) == end)
            {
                result = 1;
                break;
            }

            // 현재 지점이 벽이라면 그 위치는 9방향 체크x
            if (arr[r][c] == '#')
                continue;

            for (int d = 0; d < 9; d++)
            {
                int nr = r + dr[d];
                int nc = c + dc[d];
                if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8)
                    continue;
                // 벽을 만났으면 q에 넣지 않음
                if (arr[nr][nc] != '#')
                    q.push({ nr,nc });
            }
        }

        // 도착했으면 break
        if (result == 1)
            break;

        // 벽 이동
        moveArr();
    }
    
    cout << result;
    
    return 0;

}
```



## 약간 수정해서 개선된 코드

8초가 지나면 어차피 모든 벽은 사라지니까 무조건 도착할 수 있음을 이용해서 반복을 줄임.

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>
#include <map>

typedef long long ll;

using namespace std;
const int INF = 987654321;

vector<string> arr(8);

int dr[9] = { -1,-1,-1, 0,0,0, 1,1,1 };
int dc[9] = { -1,0,1, -1,0,1, -1,0,1 };

void moveArr()
{
    for (int i = 7; i > 0; i--)
        swap(arr[i], arr[i - 1]);
    arr[0] = "........";
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    for (int i = 0; i < 8; i++)
        cin >> arr[i];

    int result = 0; // 1은 도착
    queue<pair<int, int>> q;
    q.push({ 7,0 });
    const pair<int, int> end = make_pair(0, 7);
    int second = 0;
    
    while (!q.empty())
    {
        if (second > 8) // 더이상 벽이 존재하지 않음
        {
            result = 1;
            break;
        }

        int qsize = q.size();
        for (int i = 0; i < qsize; i++)
        {
            int r, c;
            r = q.front().first;
            c = q.front().second;
            q.pop();

            // 도착했는지 체크
            if (make_pair(r, c) == end)
            {
                result = 1;
                break;
            }

            // 현재 지점이 벽이라면 그 위치는 9방향 체크x
            if (arr[r][c] == '#')
                continue;

            for (int d = 0; d < 9; d++)
            {
                int nr = r + dr[d];
                int nc = c + dc[d];
                if (nr < 0 || nr >= 8 || nc < 0 || nc >= 8)
                    continue;
                // 벽을 만났으면 q에 넣지 않음
                if (arr[nr][nc] != '#')
                    q.push({ nr,nc });
            }
        }

        // 도착했으면 break
        if (result == 1)
            break;

        // 벽 이동
        moveArr();
        second++;
    }
    
    cout << result;
    
    return 0;

}
```

