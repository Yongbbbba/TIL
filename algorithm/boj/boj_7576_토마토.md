# BOJ_7576_토마토

- 날짜 계산을 어떻게 해야하나 고민했는데, 강의를 슬쩍 보니 미로탐색에서 거리확인할 때 썼던 방법을 여기서도 사용할 수 있었다.
- 기본적인 BFS 문제인 것 같다 



## 코드

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int N,M;
    cin >> M >> N;
    int arr[1000][1000] {0};
    // 거리찾기와 똑같이 풀면 됨
    int day[1000][1000] {0};
    bool checker = false; // 안익은 토마토 체크
    queue<pair<int, int>> q;
    // 입력받기
    for (int i=0; i<N; i++)
    {
        for (int j=0; j<M; j++) 
        {
            cin >> arr[i][j];
            // 익은 토마토를 큐 안에 넣기
            if (arr[i][j] == 1) q.push({i,j});
            // 안 익은 토마토가 있는지 체크
            if (arr[i][j] == 0) checker = true;
        }
    }

    // 안 익은 토마토 없으면 0 출력
    if (!checker)
    {
        cout << 0;
        return 0;
    }
    // 네 방향 탐색
    int dr[4] = {0, 1, 0, -1};
    int dc[4] = {1, 0, -1, 0};

    while (!q.empty())
    {
        int r = q.front().first;
        int c = q.front().second;
        q.pop();

        for (int dir=0; dir<4; dir++)
        {
            int nr = r + dr[dir];
            int nc = c  + dc[dir];
            if (nr < 0 || nr >= N || nc < 0 || nc >= M) continue;
            if (arr[nr][nc] == 0)
            {
                arr[nr][nc] = 1;
                day[nr][nc] = day[r][c] + 1;
                q.push({nr, nc});
            }
        }
    }

    // 안익은 토마토가 남아 있는지 체크
    for (int i=0; i<N; i++)
    {
        for (int j=0; j<M; j++)
        {
            if (arr[i][j] == 0)
            {
                cout << -1;
                return 0;
            }
        }
    }

    int result = 0;
    for (int i=0; i<N; i++)
    {
        for (int j=0; j<M; j++)
        {
            if (day[i][j] > result) result = day[i][j];
        }
    }


    cout << result;
    

    return 0;

}
```



## 1년 뒤 풀이 : 2022-09-23

- BFS 문제를 연달아 풀다보니까 풀 수 있었다. 이게 BFS문제인지 알아채는 것이 중요하다
- 1년 전 풀이와 로직 자체는 같다. 다만, 처음부터 다익었는지 체크하는 부분이 위 코드는 입력받을 때 bool타입 변수를 통해 체크를 한 반면에, 이번 풀이는 BFS다 하고나서 첫날 이후에 익은 토마토 존재여부를 `result==1`을 통해 체크하는 부분이 다르다

## 코드

```c++
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define ll long long

int arr[1000][1000];
int dist[1000][1000];
int n, m;
int dx[4] = { 0, 1, 0, - 1 };
int dy[4] = { 1, 0, -1, 0 };

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); 

	cin >> m >> n;

	int result = 1;
	queue<pair<int, int>> q;

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			cin >> arr[i][j];
			if (arr[i][j] == 1)
			{
				dist[i][j] = 1;
				q.push({ i,j });
			}
			
		}
	}

	while (!q.empty())
	{
		pair<int, int> now = q.front();
		q.pop();
		int x = now.first;
		int y = now.second;

		for (int d = 0; d < 4; d++)
		{
			int nx = x + dx[d];
			int ny = y + dy[d];

			if (nx < 0 || nx >= n || ny < 0 || ny >= m)
				continue;
			if (arr[nx][ny] == 0 && dist[nx][ny] == 0)
			{
				q.push({ nx, ny });
				dist[nx][ny] = dist[x][y] + 1;
				arr[nx][ny] = 1; // 익음
			}
		}
	}

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			// 안익은게 존재하는지 확인
			if (arr[i][j] == 0)
			{
				cout << -1;
				return 0;
			}
			if (dist[i][j] > result)
			{
				result = dist[i][j];
			}
		}
	}

	if (result == 1) // 처음부터 다 익었음
		cout << 0;
	else
		cout << result -1 ;

	return 0;
}
```

