# boj 11652 카드

- 숫자의 범위가 너무 크기 때문에 카운팅 정렬을 사용할 수 없음 
- 그래서 일단 입력값들을 정렬한 후에 숫자를 카운팅해서 비교하는 방법을 사용



## 틀린 코드

아래 코드가 틀린 경우는 1 1 1 4 4 4 4와 같이 마지막 숫자가 나오고 반복이 종료될 때 카운트를 비교하는 연산이 포함되어 있지 않기 때문이다.

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>

using namespace std;

#define ll long long
int N;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> N;
	vector<ll> input(N);
	for (int i = 0; i < N; i++)
		cin >> input[i];
	
	sort(input.begin(), input.end());

	// 슬라이딩 윈도우 기법 사용(?)
	ll result = input[0];  // 가장 많이 적혀있는 수
	int maxSize = 1; // 가장 많이 적혀있는 수가 적힌 횟수
	int curSize = 1; // idx번째 수가 적혀있는 횟수
	ll curNum = input[0];
	int idx = 1;

	while (idx != N)
	{
		// 앞에 나온 숫자와 같으면 curSize를 증가시키기
		// 숫자가 다르면 curSize와 maxSize를 비교하고 curSize, result 변화
		if (curNum == input[idx])
			curSize++;
		else
		{
			if (curSize > maxSize)
			{
				maxSize = curSize;
				result = curNum;
			}
			curNum = input[idx];
			curSize = 1;
		}
		idx++;
	}

	cout << result;
}


```



## 수정 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>

using namespace std;

#define ll long long
int N;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	cin >> N;
	vector<ll> input(N);
	for (int i = 0; i < N; i++)
		cin >> input[i];
	
	sort(input.begin(), input.end());

	// 슬라이딩 윈도우 기법 사용(?)
	ll result = input[0];  // 가장 많이 적혀있는 수
	int maxSize = 1; // 가장 많이 적혀있는 수가 적힌 횟수
	int curSize = 1; // idx번째 수가 적혀있는 횟수
	ll curNum = input[0];
	int idx = 1;

	while (idx != N)
	{
		// 앞에 나온 숫자와 같으면 curSize를 증가시키기
		// 숫자가 다르면 curSize와 maxSize를 비교하고 curSize, result 변화
		if (curNum == input[idx])
			curSize++;
		else
		{
			if (curSize > maxSize)
			{
				maxSize = curSize;
				result = curNum;
			}
			curNum = input[idx];
			curSize = 1;
		}
		idx++;
		if (idx == N)
		{
			if (curSize > maxSize)
				result = curNum;
		}
	}

	cout << result;
}


```

