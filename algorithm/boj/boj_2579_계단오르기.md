# boj 2579 계단 오르기

- DP로 풀이 
- 어제는 머리가 안돌아가서 도통 풀리지가 않았는데 오늘은 문제 이해부터가 잘 됐던 것 같다. 코테는 역시 컨디션이 좋을 때 응시를 해야...
- 이 문제의 포인트는 한 계단씩 오르는 것을 연속 세 번 할 수가 없는 것이다. 그래서 i번째 계단을 오를 때 한 칸 전에서 왔는지, 두 칸 전에서 왔는지를 구분해야하고, 이를 2차원 배열을 통해 나타낼 수 있었다.
- 바킹독님 영상을 보면 1차원 배열로도 해결하고 있었는데, 아직 거기까지 이해는 못하겠다.



## 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <fstream>

#define ll long long

using namespace std;

int N;
int dp[300][2]; // 첫 번째 열은 i번째 계단을 두 칸전에서 올라온 경우, 두 번째 열은 바로 한 칸 밑에서 올라온 경우
int scores[300];


int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> N;
    for (int i = 0; i < N; i++)
        cin >> scores[i];

    dp[0][0] = scores[0];
    dp[1][0] = scores[1];
    dp[1][1] = dp[0][0] + scores[1];
    dp[2][0] = max(dp[0][0], dp[0][1]) + scores[2];
    dp[2][1] = dp[1][0] + scores[2];
    // 두 칸 전에서 올라올 경우에는 연속해서 올라온 것이 아니니까 첫 번째 열
    
    for (int i = 3; i < N; i++)
    {
        // 두 칸 전에서 올라올 경우
        dp[i][0] = max(dp[i - 2][0], dp[i - 2][1]) + scores[i];
        // 한 칸 전에서 올라올 경우, dp[i-1][1]에서는 연속 세칸 밟는게 불가능하니까 올라올 수 없음
        dp[i][1] = dp[i - 1][0] + scores[i];
    }

    cout << max(dp[N - 1][0], dp[N - 1][1]);
}
```

