# boj 1107 리모컨

- 결국 못풀었던 문제. 브루트포스로 분류되어있어서 의아했는데 진짜 브루트포스였다. 목표번호 범위가 500,000이었는데 500,000이 목표 번호일 때 500,000만보다 작은 수에서 +로만 목표번호에 도달할 수 있는 것이 아니라 그 보다 큰 수에서도 도달 가능하다는 것을 고려해서 풀어야한다.
- 수많은 반례들이 있어서 그러한 반례들을 찾아내는 것도 실력인데, 난 그것을 하지 못 했다. 이런 능력이 실무할 때 꼭 필요한 능력이 아닐까 



## 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>
#include <map>
#include <list>

typedef long long ll;
#define endl '\n'

using namespace std;
const int INF = 2100000000;

bool broken[10];


// 그 숫자가 만들 수 있는 숫자인지 확인
bool isPossible(int num)
{
    string temp = to_string(num);
    for (auto c : temp)
    {
        if (broken[c - '0'] == true)
            return false;
    }
    return true;
}


int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    string n;
    int m;
    cin >> n;
    cin >> m;
    for (int i = 0; i < m; i++)
    {
        int temp;
        cin >> temp;
        broken[temp] = true;
    }

    // 목표가 100이면 result = 0
    if ("100" == n)
    {
        cout << 0;
        return 0;
    }

    if (m == 0)
    {
        cout << min((int)n.length(), abs(stoi(n) - 100));
        return 0;
    }

    if (m == 10)
    {
        cout << abs(stoi(n) - 100);
        return 0;
    }

    int result = abs(stoi(n) - 100);  // +, - 로만 만들 수 있는 최소 횟수

    for (int i = 0; i <= 1000000; i++)
    {
        // 만들 수 있는 숫자이면 그 자릿수 + (목표수 - 만든 수)
        if (isPossible(i))
        {
            int temp = to_string(i).length() + abs(i - stoi(n));
            if (result > temp)
                result = temp;
        }
    }
    
    cout << result;

    return 0;
}
```

