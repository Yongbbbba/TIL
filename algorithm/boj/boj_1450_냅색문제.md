# boj 1450 냅색문제 

- 이름도 생소한 meet in the middle이라는 방식을 이용하는 문제다.
- 완전탐색으로 물건조합을 탐색한다면 부분집합의 개수인 2^N이 된다. N이 커질 수록 시간복잡도가 기하급수적으로 올라가게 된다. 이 문제에서는 N이 최대 30이다. 
- meet in the middle 방법을 사용하는 것은 N개의 물건을 두 그룹으로 반반 나눠서 생각해보는 것이다. 그러면 각각이 2^(N/2)의 시간복잡도를 가지게 된다. 만약 최대 무게가 10이라면, 그룹1에서 x의 무게를 선택했다면 그룹2에서는 최대 10-x의 물건을 선택해야한다. 이를 이분탐색을 통해 찾아내면 logN에 탐색할 수 있다.
- 도저히 내 머리로는 생각해낼 수 없었다..
- 출처 : https://cocoon1787.tistory.com/358



## 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <fstream>
#include <set>
#include <sstream>
#include <unordered_set>

typedef long long ll;

using namespace std;
    
int N, C;
int result = 0;

vector<ll> group1, group2;
vector<ll> input(31);

void dfs(int start, int end, ll sum, vector<ll>& arr)
{
    if (sum > C)
        return;
    if (start == end)
    {
        arr.push_back(sum);
        return;
    }

    dfs(start + 1, end, sum + input[start], arr);
    dfs(start + 1, end, sum, arr);
}


int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> N >> C;
    for (int i = 0; i < N; i++)
        cin >> input[i];

    dfs(0, N / 2, 0, group1);
    dfs(N / 2, N, 0, group2);
    sort(group2.begin(), group2.end());

    for (int i = 0; i < group1.size(); i++)
        result += upper_bound(group2.begin(), group2.end(), C - group1[i]) - group2.begin();

    cout << result;
    
    return 0;
}
```

