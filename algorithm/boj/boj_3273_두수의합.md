# boj_3273_두 수의 합

- 코드 1의 방법으로 하면 시간 초과가 난다.
- N이 커지면 기하급수적으로 연산량이 늘어나기 때문이다.
- 그래서 코드 2의 방법을 사용해야한다.
- 코드 2의 로직은 다음과 같다.
  - 배열의 원소1과 다른 원소2의 합이 x라는 뜻은 배열에 `x - 원소1 == 원소2`인 원소 2가 존재한다는 뜻이다. 그러니 각 원소를 카운트해놨다가 `x - 원소1`을 만족하는 원소가 존재하는지 체크하면 된다.
  - 예를 들어서 합이 100을 만족하는 쌍을 찾아야할 때, 배열의 원소가 23이라면, 77의 값을 같는 원소가 배열에 있는지 체크하면 된다.
- 5달 뒤에 다시 풀이
  - 다시 풀어보니 도저히 접근이 안된다. 점점 바보가 되는 것 같은데.. 
  - 투포인터를 이용하면 속도도 빠르고 메모리도 덜 잡아먹는다.



## 코드 1 : O(N^2)의 시간 복잡도

```c++
#include <bits/stdc++.h>
#define N 1000000
using namespace std;

int main()
{
    int n;
    cin >> n;
    int result = 0;
    int x;
    int arr[N];
    
    for (int i=0; i < n; i++) cin >> arr[i];
    cin >> x;
    // O(N ^ 2)
    for (int i=0; i<n; i++)
    {
        for (int j=i; j < n; j++)
        {
            if (x - arr[i] == arr[j]) result++;
        }
    }

    cout << result;
    
    return 0;
}
```



## 코드 2 : O(N)의 시간 복잡도

```c++
#include <bits/stdc++.h>
#define N 1000000
using namespace std;

int main()
{
    int n;
    cin >> n;
    int result = 0;
    int x;
    int arr[N];
    // arr의 원소를 카운팅할 배열, x-arr[i] == arr[j]를 만족하는 수를 찾아낼 때 사용
    int cnt[N] = {0,};
    
    // 입력받으면서 동시에 등장한 수 카운팅, 만약 배열 입력 전에 x를 입력받았다면 바로 쌍 체크까지 가능함.
    for (int i=0; i < n; i++) 
    {
        cin >> arr[i];
        cnt[arr[i]]++;
    }
    cin >> x;
    for (int i=0; i< n; i++) if (cnt[x -arr[i]]) result++; // 합 x를 만족하는 쌍이 있는지 체크
    cout << result / 2 ; // 중복계산 제거
    
    return 0;
}
```



## 코드: 투포인터 사용

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <fstream>
#include <set>
#include <sstream>
#include <unordered_set>


typedef long long ll;

using namespace std;


int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    int N, x;
    cin >> N;
    vector<int> nums(N);

    for (int i = 0; i < N; i++)
        cin >> nums[i];
    cin >> x;
    sort(nums.begin(), nums.end());
    int start = 0;
    int end = N - 1;
    int result = 0;

    while (start < end)
    {
        int sum = nums[start] + nums[end];
        if (sum == x)
        {
            result++;
            start++;
            end--;
        }
        else if (sum < x)
            start++;
        else
            end--;
    }
    cout << result;

    return 0;
   
}

  
```



## 1년 뒤에 다시 풀이(2022.08.19)

- 알고리즘 분류에 정렬과 투포인터가 있는 것을 보고 아이디어를 풀어서 약간 반칙이긴 했으나 투포인터를 활용한 풀이를 생각해냈다. 위에 풀었던 투포인터와 아주 약간 다르다. `sum==x`일 때 start를 늘릴 필요는 없다. 

### 투포인터 풀이 

```c++
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define ll long long

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n, x;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++)
        cin >> arr[i];
    cin >> x;

    sort(arr.begin(), arr.end());

    int left = 0;
    int right = arr.size() - 1;

    int result = 0;

    while (left < right && left < arr.size() && right < arr.size())
    {
        int sum = arr[left] + arr[right];
        if (sum == x)
        {
            result++;
            right--;
        }
        else if (sum > x)
        {
            right--;
        }
        else
        {
            left++;
        }
    }

    cout << result;
	return 0;
}
```



### 위에 코드2의 응용

- 위에 적은 코드2는 돌아가지도 않는 코드임. 메모리 사용량이 많기는 하지만 투포인터는 정렬의 과정이 있기 때문에 O(nlogn)인 반면 이 풀이는 O(n)으로 풀이가 가능하다.

```c++
#include <bits/stdc++.h>
using namespace std;

int a[1000001]={};
// 각 자연수의 존재 여부를 저장하는 배열, 아래에서 x-a[i]가 1000000보다 큰 경우를 예외처리하기 싫어서 그냥 배열을 최대 200만으로 잡음
bool occur[2000001];
int n, x;

int main(void){
  ios::sync_with_stdio(0);
  cin.tie(0);

  int ans = 0;
  cin >> n;
  for(int i = 0; i < n; i++) cin >> a[i];
  cin >> x;

  for (int i = 0; i < n; i++) {
    // x-a[i]가 존재하는지 확인
    if(x-a[i] > 0 && occur[x-a[i]]) ans++;
    occur[a[i]] = true;
  }
  cout << ans;
}
```

