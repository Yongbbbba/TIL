# boj 1303 전쟁-전투

- DFS로 풀었다. 분명 맞는 것 같은데 왜 자꾸 오답이 나나 한참을 원인을 못찾았다. 어이없게도 N이 행이 아니라 열이었다. 그래서 틀렸다.
- DFS하는 부분을 함수로 빼서 작성했으면 W와 B인 경우의 중복코드가 들어갈 필요가 없었는데 이 부분이 구현에 있어서 아쉬운 부분이었다.



## 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <fstream>
#include <set>
#include <sstream>
#include <unordered_set>

typedef long long ll;

using namespace std;

int N, M;
int vis[105][105];
vector<string> arr;
int sum_w = 0;
int sum_b = 0;

int dr[4] = { 0, 1, 0, -1 };
int dc[4] = { 1, 0, -1, 0 };

stack<pair<int, int>> st;
    
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> N >> M;
    for (int i = 0; i < M; i++)
    {
        string temp;
        cin >> temp;
        arr.push_back(temp);
    }

    // 우리팀 - W
    // 상대팀 - B
    for (int i = 0; i < M; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if (arr[i][j] == 'W' && vis[i][j] == 0)
            {
                int temp = 0;
                st.push({ i,j });
                vis[i][j] = 1;
                while (!st.empty())
                {
                    int r = st.top().first;
                    int c = st.top().second;
                    st.pop();
                    temp++;
                    for (int d = 0; d < 4; d++)
                    {
                        int nr = r + dr[d];
                        int nc = c + dc[d];
                        // OOB 체크
                        if (nr < 0 || nr >= M || nc < 0 || nc >= N)
                            continue;
                        // 방문 체크
                        if (arr[nr][nc] == 'W' && vis[nr][nc] == 0)
                        {
                            st.push({ nr, nc });
                            vis[nr][nc] = 1;
                        }
                    }
                }
                sum_w += (temp * temp);
            }
            else if (arr[i][j] == 'B' && vis[i][j] == 0)
            {
                int temp = 0;
                st.push({ i,j });
                vis[i][j] = 1;
                while (!st.empty())
                {
                    int r = st.top().first;
                    int c = st.top().second;
                    st.pop();
                    temp++;
                    for (int d = 0; d < 4; d++)
                    {
                        int nr = r + dr[d];
                        int nc = c + dc[d];
                        // OOB 체크
                        if (nr < 0 || nr >= M || nc < 0 || nc >= N)
                            continue;
                        // 방문 체크
                        if (arr[nr][nc] == 'B' && vis[nr][nc] == 0)
                        {
                            st.push({ nr, nc });
                            vis[nr][nc] = 1;
                        }
                    }
                }
                sum_b += temp * temp;
            }
        }
    }

    cout << sum_w << ' '<< sum_b;

    return 0;
}

  
```

