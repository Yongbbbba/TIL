# boj 3190 뱀

- 약간 복잡한 구현 문제
- 구현에 고려해야할 문제는 1. 반복문을 돌 때 시간을 어느 시점에 증가시키고, 어느 시점에 방향을 바꿀 것인지에 대한 로직과 2. 현재 시간에 방향을 바꿔야하는지를 빠르게 체크하는 방법, 그리고 3. 꼬리를 제거하는 방법을 어떻게 할 것인지였다.
- 1. 시작 시간을 0초로 뒀다. 그리고 현재 시간에 방향을 바꿔야하는지 먼저 체크한 후에 시간을 늘려줬고, 그 다음에 한 칸 머리를 이동시킨 후에 벽에 닿거나 뱀 몸에 닿으면 break 시키고 시간을 출력시켰고, 사과와 닿았다면 꼬리는 그대로 두고 현재 칸을 뱀이 위치한 곳이라고 표시한다.
  2. O(1)에 체크하기 위하여 map 자료구조를 사용하였다.
  3. 꼬리 제거하는 부분이 까다로웠다. 처음에 작성했을 때는 꼬리가 머리의 바로 전 칸이라고 착각을 하고 코딩했는데 테스트 케이스를 돌려보니까 자꾸 틀려서 생각해보니까 그것이 꼬리가 아님을 알았다. 그러면 꼬리를 어떻게 기록하고 있을까 생각해봤는데 처음에는 방향을 꼬리와 함께 기록해줘야하나? 싶었는데 만만치 않았다. 다르게 생각해보니 뱀의 이동 경로를 계속 큐에 넣어두면, 꼬리를 이동시켜야할 때 큐에서 pop을 하고 꼬리가 위치해있던 지점을 빈칸으로 바꿔줌으로써 해결할 수 있었다. 



## 코드 

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>
#include <map>

typedef long long ll;

using namespace std;
const int INF = 987654321;

// 꼬리 여기 넣기
queue<pair<int, int>> q;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int n, k;
    cin >> n >> k;

    // 보드판 만들어서 사과 집어넣기
    vector<vector<int>> board(n, vector<int>(n));
    for (int i = 0; i < k; i++)
    {
        int r, c;
        cin >> r >> c;
        board[r-1][c-1] = 1;  // 사과 있으면 1로 표시
    }
    int l;
    cin >> l;
    
    map<int, char> m;
    for (int i = 0; i < l; i++)
    {
        int x;
        char c;
        cin >> x >> c;
        m[x] = c;
    }

    // 뱀은 2로 표시
    int result = 0;  // 현재 시간
    int direction = 0;  // 현재 뱀의 이동 방향 (오른쪽 -> 0, 아래쪽 -> 1, 왼쪽 -> 2, 위쪽 -> 3)
    // 방향 벡터
    int dr[4] = { 0,1,0,-1 };
    int dc[4] = { 1,0,-1,0 };

    // 머리 위치
    int hr = 0;
    int hc = 0;
    q.push({ 0,0 });

    board[0][0] = 2;

    // 내 몸에 닿거나 벽에 닿으면 종료
    while (true)
    {
        // 방향 바꿀 때가 됐는지 체크
        auto it = m.find(result);
        if (it != m.end())
        {
            if (m[result] == 'L')
            {
                if (direction == 0)
                    direction = 3;
                else
                    direction -= 1;
            }
            else
            {
                if (direction == 3)
                    direction = 0;
                else
                    direction += 1;
            }
        }
        // 시간 증가
        result++;

        // 이동
        int nr = dr[direction] + hr;
        int nc = dc[direction] + hc;

        // 벽에 닿았거나 내 몸과 닿았는지 체크
        if (nr < 0 || nr >= n || nc < 0 || nc >= n || board[nr][nc] == 2)
            break;

        // 사과 있는지 체크
        if (board[nr][nc] == 1)
        {
            board[nr][nc] = 2;
            hr = nr;
            hc = nc;
            q.push({ nr,nc });
        }
        else if (board[nr][nc] != 1)
        {
            board[nr][nc] = 2;
            int tr = q.front().first;
            int tc = q.front().second;
            q.pop();
            board[tr][tc] = 0;
            hr = nr;
            hc = nc;
            q.push({ hr,hc });
        }
    }

    cout << result;

    return 0;
}
```



