# boj 16197 두 동전

- 재귀를 이용한 DFS 사용
- 디버깅하는데 시간이 좀 걸렸다. 두 동전이 같은 위치에 있게 된다면 둘 중 하나만 떨어지는 상황은 발생할 수가 없으므로 여기서 가지치기를 했는데, AND 연산을 했어야 했는데 OR 연산을 해서 자꾸 오답이 나왔었다. 그리고 A동전에 대해서 처리하고 B동전을 처리할 때 앞에 코드를 복붙하는 과정에서도 변수명 수정을 제대로 해주지 않은 것이 있었다. 그외에는 구현에 가까운 문제.



## 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>
#include <map>
#include <list>

typedef long long ll;
#define endl '\n'

using namespace std;
const int INF = 987654321;

int n, m;
vector<vector<char>> arr;

int result = INF;

pair<int, int> posA = { -1,-1 };
pair<int, int> posB = { -1,-1 };

int dr[4] = { 0,1,0,-1 };
int dc[4] = { 1, 0, -1, 0 };

void dfs(pair<int, int> a, pair<int, int> b, int cnt)
{
    // 10번 넘게 버튼 누르면 끝
    if (cnt > 10)
        return;

    // 둘중 하나만 떨어졌을 때 카운트 체크
    if ((a.first == -1 && b.first != -1) || (b.first == -1 && a.first != -1))
    {
        if (cnt < result)
            result = cnt;
        return;
    }

    // 둘다 떨어졌으면 체크 x
    if ((a.first == -1 && b.first == -1))
        return;

    int ra = a.first;
    int ca = a.second;

    int rb = b.first;
    int cb = b.second;

    // 같은 위치에 있다면 더 볼 것도 없으니 return
    if (ra == rb && ca == cb)
        return;

    // 다음에 넣을 동전의 위치
    pair<int, int> nextA;
    pair<int, int> nextB;

    for (int d = 0; d < 4; d++)
    {
        int nra = ra + dr[d];
        int nrb = rb + dr[d];
        int nca = ca + dc[d];
        int ncb = cb + dc[d];

        // 밖에 떨어지는지 체크
        // a 체크
        if (nra < 0 || nra >= n || nca < 0 || nca >= m)
            nextA = { -1,-1 };
        else
        {
            // 벽인지 아닌지 체크
            if (arr[nra][nca] != '#')
                nextA = { nra,nca };
            // 벽이면 이동x
            else
                nextA = { ra, ca };
        }
        // b 체크
        if (nrb < 0 || nrb >= n || ncb < 0 || ncb >= m)
            nextB = { -1,-1 };
        else
        {
            // 벽인지 아닌지 체크
            if (arr[nrb][ncb] != '#')
                nextB = { nrb,ncb };
            // 벽이면 이동x
            else
                nextB = { rb, cb };
        }
        dfs(nextA, nextB, cnt + 1);
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    arr.resize(n, vector<char>(m));

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> arr[i][j];
            // 동전 위치 기록
            if (arr[i][j] == 'o')
            {
                if (posA.first == -1)
                    posA = make_pair(i, j);
                else
                    posB = make_pair(i, j);
            }
        }
    }

    dfs(posA, posB, 0);

    if (result == INF)
        result = -1;
    cout << result;
    
    return 0;
}
```

