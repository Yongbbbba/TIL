# boj 1753 최단경로

- 싸피 1학기 이후로 다익스트라를 공부한 적이 없어서 풀이를 못 했다.
- 다익스트라의 경우 배열을 이용하는 방법과 우선순위큐를 이용해서 풀이하는 방법이 있는데, 이 문제의 경우 배열로 풀이를 하면 메모리 초과가 난다. 그래서 우선순위큐를 사용해야한다.
- 계속 시간초과가 났는데 이유를 몰랐다. 알고보니까 우선순위큐에 데이터를 넣어줄 때 first에 dist[next]를 넣어줬어야 했는데 nextNode를 넣었는데, 최대힙이 정렬이 될 때 nextNode를 기준으로 정렬을 해버려서 이런 문제가 발생했다.



## 메모리 초과 코드 : 배열 사용

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <fstream>
#include <set>
#include <sstream>
#include <unordered_set>

typedef long long ll;

using namespace std;

int V, E;
int K;
const int INF = 987654321;
vector<bool> vis;
vector<int> dis;
vector<vector<int>> arr;

// 현재 기준에서 방문 안한 노드 중에 최단거리로 기록되어있는 index 찾기
int getSmallIndex()
{
    int min = INF;
    int idx = 1;
    for (int i = 1; i <= V; i++)
    {
        if (vis[i] == false && dis[i] < min)
        {
            idx = i;
            min = dis[i];
        }
    }
    return idx;
}

void f(int start)
{
    for (int i = 1; i <= V; i++)
    {
        dis[i] = arr[start][i];
    }
    vis[start] = true; // 시작지점 방문처리
    
    for (int i = 0; i < V; i++)
    {
        int cur = getSmallIndex();  // 방문하지 않은 노드 중에서 가장 비용이 작은 노드의 인덱스 찾기
        vis[cur] = true; // 가장 비용이 작은 노드 방문처리
        for (int j = 1; j <= V; j++)
        {
            if (!vis[j] && (dis[cur] + arr[cur][j]) < dis[j])  // 더 작은 경로가 있으면 비용 갱신
            {
                dis[j] = dis[cur] + arr[cur][j];
            }
        }
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> V >> E >> K;

    arr.resize(V + 1, vector<int>(V + 1, INF));
    vis.resize(V + 1, false);
    dis.resize(V + 1);

    for (int i = 0; i < E; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        arr[u][v] = w;
    }

    f(K);
    dis[K] = 0;

    for (int i = 1; i <= V; i++)
    {
        if (dis[i] == INF)
            cout << "INF" << '\n';
        else
            cout << dis[i] << '\n';
    }

    return 0;
}
```



## 통과코드 : 우선순위큐 사용

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>

typedef long long ll;

using namespace std;
const int INF = 987654321;
#define MAX 20005

int V, E;
int K;

int dis[MAX];  // 최단거리 기록 vector
vector<pair<int, int>>  graph[MAX];  // 경로 입력 2차원 vector, first에는 다음 노드, second에는 가중치

void dijkstra(int start)
{
    // 시작 노드를 우선순위 큐에 넣고 시작
    priority_queue<pair<int, int>> pq; // first는 현재까지의 비용, second는 현재 노드, c++의 우선순위큐는 기본적으로 최대힙. 그래서 push할 때 음수를 넣어서 처리해주면 편함
    dis[start] = 0;
    pq.push(make_pair(dis[start], start));
    while (!pq.empty())
    {
        int now = pq.top().second;
        int cost = -pq.top().first;
        pq.pop();

        for (auto& next : graph[now])
        {
            int nextNode = next.first;
            int nextCost = next.second;

            if (dis[nextNode] > cost + nextCost)
            {
                dis[nextNode] = cost + nextCost;
                pq.push(make_pair(-dis[nextNode], nextNode));
            }
        }
    }
}


int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);

    cin >> V >> E >> K;


    // 간선 입력 받기
    for (int i = 0; i < E; i++)
    {
        int u, v, w;
        cin >> u >> v >> w;
        graph[u].push_back(make_pair(v,w));
    }
    
    fill(dis + 1, dis + V + 1, INF);

    dijkstra(K);

    for (int i = 1; i <= V; i++)
    {
        if (dis[i] == INF)
            cout << "INF" << '\n';
        else
            cout << dis[i] << '\n';
    }

    return 0;
}
```



