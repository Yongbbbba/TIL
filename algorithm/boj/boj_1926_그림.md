# BOJ_1926_그림

- 수업 때 배운 dfs와 거의 흡사해서 크게 어려움은 없었다. 구현에서 자잘한 실수들이 있어서 디버깅에 시간이 조금 걸렸다. 그리고 c++로는 처음 구현을 해봐서 약간 더 걸렸다 시간이.



## 코드

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n,m;
    cin >> n >> m;
    int arr[500][500] {0};

    for (int i=0; i<n; i++)
    {
        for (int j=0; j<m; j++) cin >> arr[i][j];
    }

    pair<int, int> p; // 좌표를 담음
    queue<pair<int, int>> q; // 탐색할 좌표를 담은 큐 
    int cnt = 0; // 그림의 개수
    int maxV = 0; // 가장 큰 그림의 넓이

    // 도착했는지 체크하는 2차원 배열
    int vis[500][500] {0};
    // 네 방향 체크
    int dr[4] {0, 1, 0, -1};
    int dc[4] {1, 0, -1, 0};

    for (int i=0; i<n; i++)
    {
        for (int j=0; j<m; j++)
        {
            // 방문한 적이 없고 그림이 있는 곳이라면 큐에 넣고 방문했다고 체크
            if (arr[i][j] == 1 && vis[i][j] == 0)
            {
                p = make_pair(i, j);
                q.push(p);
                vis[i][j] = 1;
                cnt++;
                int area = 1;
                while (!q.empty())
                {
                    int r = q.front().first;
                    int c = q.front().second;
                    q.pop();

                    // 네 방향 탐색
                    for (int dir=0; dir<4; dir++)
                    {
                        int nr = r + dr[dir];
                        int nc = c + dc[dir];
                        if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                        if (arr[nr][nc] == 1 && vis[nr][nc] == 0)
                        {
                            p = make_pair(nr, nc);
                            q.push(p);
                            vis[nr][nc] = 1;
                            area++;
                        }
                    }
                }
                if (maxV < area) maxV = area;
            }
        }
    }
    cout << cnt << '\n' << maxV;
    return 0;

}
```



## 1년뒤 풀이 : 2022-09-22

- 오랜만에 BFS를 풀었더니 이런 기본적인 문제도 바로 풀지를 못하였다. 기계처럼 나가야하는데 내일 모레 코테 어떻게 볼 수 있을지 걱정이다.
- 그림이 없는 경우에 0을 출력해야하는데 -1을 출력하고 있어서 두 번 오답이 났으나 해결했다.

## 코드

```c++
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define ll long long

int arr[510][510];
int vis[510][510];
int n, m;
int dx[4] = { 0, 1, 0, - 1 };
int dy[4] = { 1, 0, -1, 0 };

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); 

	cin >> n >> m;

	int maxArea = 0;
	int cnt = 0;
	queue<pair<int, int>> q;

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			cin >> arr[i][j];
					}
	}

	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			if (arr[i][j] == 1 && vis[i][j] == 0)
			{
				cnt++;
				int area = 1;
				vis[i][j] = 1;
				q.push({ i,j });
				while (!q.empty())
				{
					pair<int, int> now = q.front();
					q.pop();
					int x = now.first;
					int y = now.second;

					for (int d = 0; d < 4; d++)
					{
						int nx = x + dx[d];
						int ny = y + dy[d];

						if (nx < 0 || nx >= n || ny < 0 || ny >= m)
							continue;
						if (arr[nx][ny] == 1 && vis[nx][ny] == 0)
						{
							area++;
							q.push({ nx,ny });
							vis[nx][ny] = 1;
						}
					}
				}
				if (area > maxArea)
				{
					maxArea = area;
				}
			}
		}
	}

	cout << cnt << endl;
	cout << maxArea;
	return 0;
}
```

