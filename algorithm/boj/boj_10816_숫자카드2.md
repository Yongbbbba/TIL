# boj 10816 숫자카드 2

- 이진탐색으로 분류되어있는 문제였는데, 숫자범위가 그렇게 크지 않아서 카운팅 배열을 만들어서 구하는게 간편하고 빠름... 하지만 이진탐색으로도 풀어봐야겠다.



## 카운팅 정렬 사용 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <fstream>

#define ll long long

using namespace std;

int N, M;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> N;
    vector<int> cnt(20'000'010);
    for (int i = 0; i < N; i++)
    {
        int num;
        cin >> num;
        cnt[num+10'000'000]++;
    }

    cin >> M; 
    for (int i = 0; i < M; i++)
    {
        int num;
        cin >> num;
        cout << cnt[num+10'000'000] << ' ';
    }
}
```



## 이분탐색 이용한 코드

upper_bound와 lower_bound를 이용하면 되는데, 직접 구현할 수 있는지 체크해보자.

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <fstream>

#define ll long long

using namespace std;


int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N, M; 
    cin >> N;
    vector<int> cards(N);
    for (int i = 0; i < N; i++)
        cin >> cards[i];
    sort(cards.begin(), cards.end());
    cin >> M;
    while (M--)
    {
        int num;
        cin >> num;
        cout << upper_bound(cards.begin(), cards.end(), num) - lower_bound(cards.begin(), cards.end(), num) << ' ';
    }
    
}
```

