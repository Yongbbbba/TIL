# boj 1759 암호 만들기

- 조합을 이용해서 풀이
- 만들어진 문자열이 조건에 맞는지 확인하는 것은 어렵지 않음
- 이 풀이에서 input을 sort하는 과정이 필요하다. 조합을 next_permutation으로 구할 때 flag arr를 00011이런 식으로 만들고 0인 경우에 temp string에 추가하기 때문이다. 정렬을 안하면 모든 경우의 수를 체크하지 못한다.



## 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>
#include <map>
#include <list>

typedef long long ll;
#define endl '\n'

using namespace std;
const int INF = 2100000000;

int l, c;
vector<char> arr;
vector<char> mo = { 'a', 'e','i', 'o','u' };

bool check(string s)
{
    int moCnt = 0;
    int jaCnt = 0;

    for (int i = 0; i < s.length(); i++)
    {
        if (i != 0 && s[i] <= s[i - 1])
            return false;
        bool foundMo = false;
        for (auto m : mo)
        {
            if (m == s[i])
            {
                moCnt++;
                foundMo = true;
                break;
            }
        }
        if (!foundMo)
            jaCnt++;
    }

    if (moCnt >= 1 && jaCnt >= 2)
        return true;

    return false;
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> l >> c;
    arr.resize(c);
    for (int i = 0; i < c; i++)
        cin >> arr[i];

    sort(arr.begin(), arr.end());

    // 조합 활용해서 풀이
    vector<int> flag(c, 1);
    for (int i = 0; i < l; i++)
        flag[i] = 0;

    do
    {
        string s = "";
        for (int i = 0; i < c; i++)
        {
            if (flag[i] == 0)
                s += arr[i];
        }
        if (check(s))  // 암호의 조건을 충족하는지 확인
        {
            cout << s << endl;
        }
    } while (next_permutation(flag.begin(), flag.end()));

    return 0;
}
```

