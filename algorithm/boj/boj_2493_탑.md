# BOJ_2493_탑

- 뭔짓을 해도 시간초과가 나는 중
- 내 코드는 시간 복잡도가 O(N^2)이라서 이걸 줄여야하는데 어디서 어떻게 줄여야하는지 감을 못잡겠다.
- 스택을 사용하면 좋겠다는 생각이 어렴풋이 들었는데(문제집 분류가 스택이었으니 당연한건가..) 뭔가 잡힐듯말듯한 느낌이 계속 들었다. 그러다 실패하고, 다른 답안을 봤는데, 맞춰지지 않던 퍼즐이 맞춰진 느낌이었다. 계속된 딜레마인데 답안을 보는 것이 좋은지, 아니면 며칠 걸리더라도 계속 생각해보는 것이 좋은지 고민이다.



## 코드 1

```python
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N;
    cin >> N;
    int result[500001] {0,};
    int arr[500001] {0,};
    
    for (int i=1; i<N+1; i++) 
    {
        cin >> arr[i];
        // 이전에 나온 것 중에 나보다 큰 빌딩이 있는지 체크
        for (int j=i-1; j>=1; j--)
        {
            if (arr[j] > arr[i]) 
            {
                result[i] = j;
                break;
            }
        }
        cout << result[i] << ' ';
    }

    return 0;

}
```



## 코드2 : 스택을 활용한 방법

```python
#include <bits/stdc++.h>

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N;
    cin >> N;
    stack<pair<int, int>> s;
    int num;

    for (int i=1; i<N+1; i++) 
    {
        cin >> num;
        
        while (true)
        {
            // 스택이 비었으면 나보다 큰 빌딩은 왼쪽에 없다는 뜻이니 0 출력
            if (s.empty())
            {
                cout << 0 << ' ';
                s.push(pair<int,int>(i, num));
                break;
            }
            // 나보다 큰 빌딩이 아니라면 pop, 내 뒤에 나올 놈들은 어차피 나에게 막힐 것임
            else if (s.top().second <= num ) s.pop();
            else 
            {
                // 나보다 큰 빌딩 발견하면 걔한테 막힐 것이므로 걔 출력해주고 나도 스택에 쏙
                cout << s.top().first << ' ';
                s.push(pair<int,int>(i, num));
                break;
            }

        }
    }

    return 0;

}
```



## 1년 뒤 풀이 : 2022-09-05

- 답안을 보고나서야 풀었음
- 스택을 이용하였다. 현재가 i번째일 때 i+x번째 탑이 i번째보다 작을 경우에는 1~(i-1)번째 탑과 닿을 일이 없음. 그러니까 i번째일 때 i번째보다 작은 것들은 pop해도 되는 것을 이용하였다.

### 코드 

```c++
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define ll long long

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	int n;
	cin >> n; 

	stack<pair<int, int>> s;
	s.push({ 100000001, 0 });
	
	// 현재가 i번째일 때 i+x번째 탑이 i번째보다 작을 경우에는 1~(i-1)번째 탑과 닿을 일이 없음. 그러니까 i번째일 때 i번째보다 작은 것들은 pop해도 됨

	for (int i = 0; i < n; i++)
	{
		int now;
		cin >> now;
		while (s.top().first < now)
		{
			s.pop();
		}
		cout << s.top().second << ' ';
		s.push({ now, i + 1 });
	}
	
	return 0;
}
```

