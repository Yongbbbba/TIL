# boj 2295 세 수의 합

- 이진탐색으로 풀었다. 그런데 이게 이진탐색 문제인지 모르고 풀었으면 이진탐색으로 풀 생각을 했을까 싶다.
- 곧이곧대로 풀면 O(N^4)에 해결할 수 있는 문제지만 입력값이 조금만 커져도 시간초과가 난다. 그렇기 때문에 복잡도를 줄이는 풀이를 생각해내야 하는데,  O(N^2 logN)까지 줄여볼 수 있다.
- 계속 오답이 났는데, 문제 조건을 꼼꼼하게 체크하지 못한 탓이다. 중복된 수를 선택할 수 있는데 그것을 빼고 풀이를 해서 계속 오답이 났다.



## 코드 

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <fstream>
#include <set>

#define ll long long

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    // a[i] + a[j] + a[k] = a[l]
    // O(N^4)으로 풀 수 있지만 O(N^2logN)으로 줄일 수 있다.
    // a[i] + a[j]의 값을 배열로 만든다. (O(n^2)), 그리고 이를 정렬한다(O(nlogn))
    // 2중반복을 돌면서 a[l] - a[k]이 two 배열에 있는지 이분탐색을 통해 찾는다. (O(N^2logN))

    int N;
    cin >> N;
    
    vector<int> nums(N);
    for (int i = 0; i < N; i++)
        cin >> nums[i];

    sort(nums.begin(), nums.end());

    vector<int> two;
    for (int i = 0; i < N; i++)
    {
        for (int j = i; j < N; j++)
            two.push_back(nums[i] + nums[j]);
    }
    sort(two.begin(), two.end());


    for (int i = N - 1; i >= 0; i--)
    {
        for (int j = 0; j < i; j++)
        {
            int diff = nums[i] - nums[j];
            if (binary_search(two.begin(), two.end(), diff))
            {
                cout << nums[i];
                return 0;
            }
        }
    }
}

  
```

