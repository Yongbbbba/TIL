# boj 1039 교환

- 생각보다 너무 어려워서 놀랐던 문제이다. 문제 이해가 어려웠는데 만약 연산을 K번 할 수 없으면 -1을 출력한다라는 조건의 의미가 뭔말인지 캐치를 못 했다. 이 뜻은 입력 숫자가 한 자리 수이면 스왑을 할 수가 없으니까 -1을 출력해야하고, 또는 스왑을 하면 맨 앞자리 수에 0밖에 나올 수 없는 경우에도 -1을 출력해야한다.
- 시간과 메모리를 아끼기 위해서는 set을 활용해서 현재 레벨에 동일한 숫자가 queue에 들어있지 않게 관리해주는 것이 중요하다. 예를 들어서 1234를 스왑해서 4231이 나와서 큐에 넣었는데, 다른 어떤 숫자를 스왑해서 동일하게 4231이 나왔다면 그걸 또 큐에 넣을 필요는 없다.
- 다른 풀이를 봤는데 이해가 잘 안돼서 나는 만약 다섯자리수가 들어오면 5C2 index 조합을 미리 만들어두고 swap을 시켰다.
- 참고 : https://kibbomi.tistory.com/176

## 코드 

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>

typedef long long ll;

using namespace std;
const int INF = 987654321;

string N;
int K;

vector<pair<int, int>> c_set;

// N에서 숫자 두 개를 뽑아 스왑할 수 있는 인덱스 조합의 경우의 수를 미리 만들어둔다.
void makeCombination(vector<int>& arr)
{
    // NC2
    vector<int> a(N.length(), 1);
    a[0] = 0;
    a[1] = 0;

    do
    {
        vector<int> temp;
        for (int i = 0; i < a.size(); i++)
        {
            if (a[i] == 0)
                temp.push_back(arr[i]);
        }
        c_set.push_back(make_pair(temp[0], temp[1]));
    } while (next_permutation(a.begin(), a.end()));
}


int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> N >> K;

    // 이 예외처리 안해주면 만약 N이 한 자리 수일 때 스왑하는 경우 자체가 존재할 수 없으므로 오답이 된다.
    if (N.length() == 1)
    {
        cout << -1;
        return 0;
    }
    // 1의 자리수가 0인데 두 자릿수라면 swap 자체가 안되니까 뒤는 볼 것도 없다.
    if (N.length() == 2 && N[1] == 0)
    {
        cout << -1;
        return 0;
    }
    
    // 0 ~ N.length()-1만큼의 인덱스 중에서 2개를 뽑는 조합의 경우의 수를 미리 구해둔다.
    vector<int> temp(N.length());
    for (int i = 0; i < temp.size(); i++)
        temp[i] = i;
    makeCombination(temp);
    queue<string> q;
    q.push(N);

    while (K--)
    {
        // BFS 사용
        int qsize = q.size();
        set<string> s;
        for (int k = 0; k < qsize; k++)
        {
            string top = q.front();
            q.pop();

            // 이 부분이 핵심이다. 이거 안하면 큐가 너무 커져서 메모리 초과가 난다. 큐를 전역에 두면 메모리 초과가 안나긴 하겠지만.. 연산 시간을 절감시켜줄 것이다.
            if (s.count(top) != 0)
                continue;
            s.insert(top);
          
            for (int i = 0; i < c_set.size(); i++)
            {
                int left = c_set[i].first;
                int right = c_set[i].second;
                swap(top[left], top[right]);
                if (top[0] != '0')
                    q.push(top);
                swap(top[left], top[right]);
            }
        }
    }

    if (q.empty())
    {
        cout << -1;
        return 0;
    }
    else
    {
        string result = q.front();
        while (!q.empty())
        {
            string temp = q.front();
            q.pop();
            if (temp > result)
                result = temp;
        }
        cout << result;
        return 0;
    }

}
```

