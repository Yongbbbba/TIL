# boj 2529 부등호

- 실버 2가 맞나..? 꽤 애먹은 문제 
- 최댓값, 최솟값과 현재까지 완성된 숫자를 비교할 때 처음에 stoi를 사용했었는데, interger overflow가 일어나는 것을 예측 못했다. stoll로 고쳐서 통과했다. 
- 그런데 굳이 숫자로 바꿔서 대소비교를 할 필요없이 문자열로 바로 대소비교를 해도 문제 요구사항에 맞는 풀이였다. 당연히 속도도 약간 빨라졌다. 
- 파라미터로 현재까지 완성된 숫자를 넣어주면서 백트랙킹 식으로 풀이하였다. 그리고 부등호가 들어있는 배열을 따로 만들고, 이것의 인덱스를 파라미터로 넣어줬다.
- 파라미터로 넣어준 숫자를 담아주는 문자열의 길이가 0이면 최초의 상황이기에 숫자를 넣어주고 다음 단계로 탐색한다. 근데 이때 문자열의 길이가 0이 아닌 경우와 분기처리를 해주지 않으면 문제가 생긴다.



## 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>
#include <map>
#include <list>

typedef long long ll;
#define endl '\n'

using namespace std;
const int INF = 987654321;

int n;
vector<char> input;

string minV = to_string(9999999999);
string maxV = to_string(-9999999999);

vector<int> vis(10);

void f(int idx/*부등호 idx*/, string s)
{
    if (s.length() == n + 1)
    {
        if (s > maxV)
            maxV = s;
        if (s < minV)
            minV = s;
        return;
    }

    for (int i = 0; i < 10; i++)
    {
        if (s.length() == 0)
        {
            vis[i] = 1;
            f(idx, s + to_string(i));
            vis[i] = 0;
        }
        else
        {

            int a = s.back() - '0';
            if (vis[i] == 0)
            {
                if ((input[idx] == '<') && (a < i))
                {
                    vis[i] = 1;
                    f(idx + 1, s + to_string(i));
                    vis[i] = 0;
                }
                else if ((input[idx] == '>') && (a > i))
                {
                    vis[i] = 1;
                    f(idx + 1, s + to_string(i));
                    vis[i] = 0;
                }
            }
        }
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    input.resize(n);
    for (int i = 0; i < n; i++)
        cin >> input[i];

    f(0, "");

    cout << maxV << endl << minV;
        
    return 0;
}
```

