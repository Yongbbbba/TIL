# boj 1644 소수의 연속합

- 어제 현카 코테 문제에서 투 포인터로 풀 수 있는 문제가 나왔는데 구현을 못 했다. 그래서 투포인터 문제를 풀면서 다시 감을 찾기로 하였는데, 어제 유난히 컨디션 난조로 머리가 돌아가지 않아서 풀리지 않던 문제를 오늘은 다행히 구현할 수 있었다.
- 에라토스테네스의 체 방법을 통해 N까지의 소수를 구한 후에 prefix sum을 이용해서 풀이를 하였다.



## 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <fstream>
#include <set>
#include <sstream>
#include <unordered_set>


typedef long long ll;

using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int N;
    cin >> N;

    // N까지의 소수의 수를 구하기 (NlogN)
    vector<bool> primes(N + 1);  // false면 소수
    primes[0] = true;
    primes[1] = true;
    for (int i = 2; i <= N; i++)
    {
        if (primes[i])
            continue;
        for (int j = 2 * i; j <= N; j += i)
        {
            primes[j] = true;
        }
    }
    // N까지의 구간합을 구하기 (N)
    vector<int> primeSum{ 0 }; // 구간합 구하기
    for (int i = 2; i <= N; i++)
    {
        if (!primes[i]) // 소수라면
        {
            primeSum.push_back(primeSum.back() + i);
        }
    }

    int result = 0;
    int left = 0;
    int right = 0;
    while (left <= right && right < primeSum.size())
    {
        int sum = primeSum[right] - primeSum[left];
        if (sum == N)
        {
            result++;
            right++;
        }
        else if (sum < N)
        {
            right++;
        }
        else
            left++;
    }

    cout << result;
    
    return 0;
}
```

