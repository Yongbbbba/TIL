# boj 2252 줄 세우기 

- 위상정렬을 처음 배워서 활용
- 위상정렬을 사용하기 위해서는 방향성이 있고 사이클이 없는 그래프에서만 가능하다.
- 풀이 방법은 다음과 같다
  - 특정 노드로 들어오는 간선의 수를 진입 차수라고 한다. 이런 진입 차수가 0인 노드를 큐에 넣는다.
  - 큐가 비어있을 때까지 무한루프를 돈다. 큐의 front와 연결된 간선을 제거하고, 그 간선에 있던 다음 노드의 진입 차수를 1만큼 줄인다.
  - 만약 1만큼 줄인 노드의 진입 차수가 0이 됐을 경우에 큐에 넣는다.



## 코드

```c++
#include <iostream>
#include <algorithm>
#include <vector>
#include <cctype>
#include <stack>
#include <queue>
#include <array>
#include <set>
#include <sstream>
#include <map>

typedef long long ll;
#define endl '\n'

using namespace std;
const int INF = 987654321;

int n, m;

vector<int> arr[32005];
int inDegree[32005]; // 진입차수

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    cin >> n >> m;

    for (int i = 0; i < m; i++)
    {
        int u, v;
        cin >> u >> v;
        arr[u].push_back(v);
        inDegree[v] += 1;
    }

    // 위상정렬 사용
    // 진입차수가 0인 노드를 큐에 넣는다. 
    // 진입차수가 0인 노드에서 나가는 간선은 삭제한다.
    // 그 노드에서 다음 차수의 노드가 진입차수가 0이라면 큐에 넣는다.

    queue<int> q;
    for (int i = 1; i <= n; i++)
    {
        if (inDegree[i] == 0)
            q.push(i);
    }

    while (!q.empty())
    {
        int cur = q.front();
        q.pop();
        cout << cur << ' ';
        for (auto node : arr[cur])
        {
            inDegree[node]--;
            if (inDegree[node] == 0)
                q.push(node);
        }
    }

    return 0;
}
```

